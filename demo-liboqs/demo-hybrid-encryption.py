# ######################################################################
# Preparation
# ######################################################################

import os
import oqs
import base64
import binascii
from pprint import pprint
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC


# ######################################################################
# Check the library information
# ######################################################################

print("liboqs version:", oqs.oqs_version())
print("liboqs-python version:", oqs.oqs_python_version())
print("\nEnabled KEM mechanisms:")
kems = oqs.get_enabled_KEM_mechanisms()
pprint(kems, compact=True)
print()


# ######################################################################
# Helper Function
# ######################################################################
def key_transform(key, salt):
    """
    This function transforms an KEM key to the format
    of 32 url-safe base64-encoded bytes.

    Input:
        key (bytes in binary format): the key from KEM
        salt (bytes): a string generated by os.urandom(16)
    Return:
        key_ (bytes in base64 format): the key used for SKE

    Source: cryptography.io/en/latest/
            fernet/#using-passwords-with-fernet
    """
    password = binascii.hexlify(key)
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(),
                     length=32,
                     salt=salt,
                     iterations=480000)
    key_ = base64.urlsafe_b64encode(kdf.derive(password))

    return key_


# ######################################################################
# KEM for Message Encryption
# ######################################################################
# ======================================================================
# 0. Initialization
# ======================================================================
kem_algo = 'Kyber512'
sender = oqs.KeyEncapsulation(kem_algo)

# 1. Sender generates the key pair
public_key = sender.generate_keypair()
secret_key = sender.export_secret_key()

print('The following keys are displayed in part with utf-8 style.\n')
print('========= Key pair generation (by sender) =========')
print('KEM public key:', binascii.hexlify(public_key)[:10])
print('KEM secret key:', binascii.hexlify(secret_key)[:10])
print()


# ======================================================================
# 2. Sender Encryption
# ======================================================================
# 2.1. Sender generates ciphertext and key
ciphertext, key = sender.encap_secret(public_key)

print('========= Encryption (by sender) =========')
print('------ Step 1: Encapsulation ------')
print('KEM ciphertext:', binascii.hexlify(ciphertext)[:10])
print('KEM key (sender):', binascii.hexlify(key)[:10])
print()

# 2.2. Encrypt the private key on web3 (i.e., message)
# 2.2.1. Encrypt the private key used on blockchain in utf-8 format
message = base64.b64encode(os.urandom(32)).decode('utf-8')
message = '5906cbe7c9939c405a29b54226a26017dccee89e395d219b7f63e2dc8ed3b9ce'
print('------ Step 2: Symmetric Encryption ------')
print(f'Original web3 private key:\n{message}.\n')

# 2.2.2. Transform the key to a symmetric key (p.s. info may lose here)
salt = os.urandom(16)
key_ = key_transform(key, salt)

# 2.2.3. Encrypt the private key used on blockchain by the transformed key
fernet = Fernet(key_)
private_key_web3_encrypted = fernet.encrypt(message.encode())
print(f'Encrypted web3 private key: '
      f'(symmetrically encrypted using the KEM key)'
      f'\n{private_key_web3_encrypted}.\n')
print(f'Outputs for the receiver: \n'
      '- encrypted web3 private key\n'
      '- ciphertext\n'
      '- secret key\n'
      '- salt (for key transformation)\n')
print('Our clients will only hold the encrypted web3 private key.\n'
      'They can request the other three from us if needed under 2FA.\n')

# ======================================================================
# 3. Receiver Decryption
# ======================================================================
# 3.1. Receiver recovers the key by secret key and the ciphertext
receiver = oqs.KeyEncapsulation(kem_algo, secret_key)
key_receiver = receiver.decap_secret(ciphertext)

print('========= Decryption (by receiver) =========')
print('------ Step 1: Decapsulation ------')
print('Decapsulated KEM key:',
      binascii.hexlify(key_receiver)[:10], '(decapsulated using ciphertext and secret key)\n')

# 3.2. Receiver decrypt the message by the key
key_receiver_ = key_transform(key_receiver, salt)
fernet_receiver = Fernet(key_receiver_)
private_key_web3_decrypted = fernet_receiver.decrypt(private_key_web3_encrypted).decode()
print('------ Step 2: Symmetric Decryption ------')
print(f'The receiver then decrypt the web3 private key '
      f'(by the decapsulated KEM key and salt):\n{private_key_web3_decrypted}.')
print()
